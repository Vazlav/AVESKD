// СписокЗначений		0-

// ТаблицаЗначений
//		Колонки				0-
//		Строки				0-

// XBase					
//		Поля        	0-
//		Строки				1-
//

//**********************************************************************
Функция сис_ЧислоСекундСПолуночи(Знач пар_Время) Экспорт 
	// пар_Время без даты 00[:00[:00]]
	пер_Время = СокрЛП(пар_Время);
	
	Если СтрДлина(пер_Время)=8 Тогда
		// ЧЧ:ММ:СС
		Возврат ОМ20_Чернов._Число(Лев(пер_Время,2))*60*60+ОМ20_Чернов._Число(Сред(пер_Время,4,2))*60+ОМ20_Чернов._Число(Прав(пер_Время,2));
	ИначеЕсли СтрДлина(пер_Время)=5 Тогда
		// ЧЧ:ММ
		Возврат ОМ20_Чернов._Число(Лев(пер_Время,2))*60*60+ОМ20_Чернов._Число(Сред(пер_Время,4,2))*60;
	КонецЕсли;
	
	// ЧЧ
	Возврат ОМ20_Чернов._Число(Лев(пер_Время,2))*60*60;
КонецФункции

Функция удалить_сис_ОчередноеВремяДляТаймера(Знач пар_Время) Экспорт 
	// пар_Время без даты 00[:00[:00]] - несколько значений разделенных ;
	
	сз_Время = Новый СписокЗначений;
	ОМ20_Чернов.Стр_ВСписокЗначений(сз_Время, пар_Время, ";");
	сз_Время.СортироватьПоЗначению();
	
	пер_ТекВр = Формат(ТекущаяДата(),"ДФ=HH:mm:ss");
	Для Каждого стр из сз_Время Цикл
		Если сис_ЧислоСекундСПолуночи(стр.Значение)>сис_ЧислоСекундСПолуночи(пер_ТекВр) Тогда
			Возврат сис_ЧислоСекундСПолуночи(стр.Значение)-сис_ЧислоСекундСПолуночи(пер_ТекВр);
		КонецЕсли;
	КонецЦикла;
	
	Возврат 24*60*60-сис_ЧислоСекундСПолуночи(пер_ТекВр)+сис_ЧислоСекундСПолуночи(сз_Время[0].Значение)
КонецФункции

//**********************************************************************
Функция _Число(Знач пар_1=0) Экспорт
	а=0;
	Попытка
		а=Число(пар_1);
	Исключение
	КонецПопытки;
	
	Возврат а;
КонецФункции

Функция _Дата(Знач пар_1="") Экспорт
	а=Дата("00010101");
	Попытка
		а=Дата(пар_1);
	Исключение
	КонецПопытки;
	
	Возврат а;
КонецФункции

Функция _СтрокаСоединенияПрайса() Экспорт
	пер_ИНН = Константы.ОсновнаяФирма.Получить().ИНН;
	пер_1="";
	
	Если 			(пер_ИНН="7717569428") Тогда
		// ТС Аптечка
		пер_1 = "IP=z170; DB=a5v2; PASS=;";
	ИначеЕсли (пер_ИНН="7718761036") Тогда
		// Аптека 65
		пер_1 = "IP=z170; DB=a5v2; PASS=;";
	ИначеЕсли (пер_ИНН="7702239699") Тогда
		// Пресса 2000
		пер_1 = "IP=z170; DB=a5v2; PASS=;";
	ИначеЕсли (пер_ИНН="7736150304") Тогда
		// Стиль-Фарма
		пер_1 = "IP=a5-db; DB=StyleFarma; PASS=1925624;";
	ИначеЕсли (пер_ИНН="7729603391") Тогда
		// Биона
		пер_1 = "IP=a5-db; DB=SF_UL02; PASS=1925624;";
	КонецЕсли;
	
	пер_1=СтрЗаменить(пер_1, "IP="	, "Provider=SQLOLEDB.1;Data Source=");
	пер_1=СтрЗаменить(пер_1, "DB="	, "Initial Catalog=");
	пер_1=СтрЗаменить(пер_1, "PASS=", "User Id=sa;Password=");
	
	Возврат пер_1;
КонецФункции

Функция _Дней(Знач пар_Дней) Экспорт
	Возврат 60*60*24*пар_Дней;
КонецФункции

Функция _Строка(Знач пар_1) Экспорт
	Если Строка(ТипЗнч(пар_1))="Число" Тогда
		Возврат Формат(пар_1,"ЧГ=0");
	КонецЕсли;
	
	Возврат Строка(пар_1);
КонецФункции

//**********************************************************************
Функция ч_ОкрДо5копВниз(Знач пар_Цена=0) Экспорт 
	Возврат Цел(пар_Цена*10)/10+?((пар_Цена*100-Цел(пар_Цена*10)*10)<5,0,0.05);
КонецФункции	

Функция ч_ОкрДо50копВниз(Знач пар_Цена=0) Экспорт
	Возврат ?((пар_Цена-Цел(пар_Цена))<0.5, Цел(пар_Цена), Цел(пар_Цена)+0.5);
КонецФункции	

//**********************************************************************
Функция Стр_ПолучитьДатуИФормат(Знач пар_1, пар_Формат) Экспорт
	пар_Формат="";
	
	Если Строка(ТипЗнч(пар_1))="Дата" Тогда
		// Если это итак дата
		пар_Формат="Дата";
		Возврат пар_1;
	КонецЕсли;
	
	пер_1=Стр_СтрУдалитьДвойныеПробелы(Строка(пар_1));
	
	Если (СтрДлина(пер_1)>10) Тогда
		пер_тмп = _Дата(Лев(пер_1,8));
		Если пер_тмп<>_Дата("") Тогда
			// Если дата нормально преобразовывается (может быть еще и время, ниже все без учета времени)
			пар_Формат="ГГГГММДД";
			Возврат пер_тмп;
		КонецЕсли;
	ИначеЕсли (СтрДлина(пер_1)=10) Тогда
		Если (_Число(Прав(пер_1,4))>1900) Тогда
			пар_Формат="ДД/ММ/ГГГГ";
			Возврат _Дата(Прав(пер_1,4)+Сред(пер_1,4,2)+Лев(пер_1,2));
		ИначеЕсли (_Число(Лев(пер_1,4))>1900) Тогда
			пар_Формат="ГГГГ/ММ/ДД";
			Возврат _Дата(Лев(пер_1,4)+Сред(пер_1,6,2)+Прав(пер_1,2));
		КонецЕсли;
	ИначеЕсли СтрДлина(пер_1)=8 Тогда
		Если _Число(пер_1)>0 Тогда
			Если (Число(Прав(пер_1,4))>1900) Тогда
				пар_Формат="ДДММГГГГ";
				Возврат _Дата(Прав(пер_1,4)+Сред(пер_1,3,2)+Лев(пер_1,2));
			ИначеЕсли (Число(Лев(пер_1,4))>1900) Тогда
				пар_Формат="ГГГГММДД";
				Возврат _Дата(Лев(пер_1,4)+Сред(пер_1,5,2)+Прав(пер_1,2));
			КонецЕсли;
		Иначе
			пар_Формат="ДД/ММ/ГГ";
			Возврат _Дата(?(_Число(Прав(пер_1,2))>50,"19","20")+Прав(пер_1,2)+Сред(пер_1,4,2)+Лев(пер_1,2));
		КонецЕсли;
	ИначеЕсли СтрДлина(пер_1)=6 Тогда
		пар_Формат="ДДММГГ";
		Возврат _Дата(?(_Число(Прав(пер_1,2))>50,"19","20")+Прав(пер_1,2)+Сред(пер_1,3,2)+Лев(пер_1,2));
	КонецЕсли;
	
	Возврат _Дата();
КонецФункции

Функция Стр_ПолучитьДату(Знач пар_1) Экспорт
	пер_1="";
	Возврат Стр_ПолучитьДатуИФормат(пар_1, пер_1);
КонецФункции

Функция Стр_ПолучитьДатуПоФормату(Знач пар_1, Знач пар_Формат) Экспорт
	Если Строка(ТипЗнч(пар_1))="Дата" Тогда
		Возврат пар_1;
	КонецЕсли;
	
	пер_1=Стр_СтрУдалитьДвойныеПробелы(Строка(пар_1));
	
	Если 			пар_Формат="ДД/ММ/ГГГГ" Тогда
		Возврат _Дата(Прав(пер_1,4)+Сред(пер_1,4,2)+Лев(пер_1,2));
	ИначеЕсли пар_Формат="ДД/ММ/ГГ"		Тогда
		Возврат _Дата(?(_Число(Прав(пер_1,2))>50,"19","20")+Прав(пер_1,2)+Сред(пер_1,4,2)+Лев(пер_1,2));
	ИначеЕсли	пар_Формат="ГГГГММДД"		Тогда
		Возврат _Дата(Лев(пер_1,8));
	ИначеЕсли пар_Формат="ДДММГГГГ"		Тогда
		Возврат _Дата(Прав(пер_1,4)+Сред(пер_1,3,2)+Лев(пер_1,2));
	ИначеЕсли пар_Формат="ДДММГГ"			Тогда
		Возврат _Дата(?(_Число(Прав(пер_1,2))>50,"19","20")+Прав(пер_1,2)+Сред(пер_1,3,2)+Лев(пер_1,2));
	ИначеЕсли пар_Формат="ГГГГ/ММ/ДД" Тогда
		Возврат _Дата(Лев(пер_1,4)+Сред(пер_1,6,2)+Прав(пер_1,2));
	КонецЕсли;
	
	Возврат _Дата();;
КонецФункции

Функция Стр_ПолучитьФорматДаты(Знач пар_1) Экспорт
	пер_1="";
	Стр_ПолучитьДатуИФормат(пар_1, пер_1);
	Возврат пер_1
КонецФункции

Функция Стр_ПолучитьЧисло(Знач пар_1) Экспорт
	пер_Результат="0";
	пер_1=СтрЗаменить(СокрЛП(Строка(пар_1)),",",".");
	
	Для пер_Симв=1 По СтрДлина(пер_1) Цикл
		Если Найти("0123456789.",Сред(пер_1,пер_Симв,1))>0  Тогда
			пер_Результат=пер_Результат+Сред(пер_1,пер_Симв,1);
		КонецЕсли;
	КонецЦикла;

	Возврат _Число(пер_Результат);
КонецФункции

Функция Стр_СтрУдалитьДвойныеПробелы(Знач пар1="") Экспорт
	пар1=СокрЛП(пар1);
	пер_тмп=Найти(пар1,"  ");
	Пока пер_тмп>0 Цикл
		пар1=СтрЗаменить(пар1,"  "," ");
		пер_тмп=Найти(пар1,"  ");
	КонецЦикла;
	Возврат пар1;
КонецФункции

Функция Стр_ШК13_Верный(Знач пар_ШтрихКод="") Экспорт
	Перем КонтрольнаяСумма,Четные,Нечетные,Общее,Результат,ПроверкаДесятка;
		
	пар_ШтрихКод=СокрЛП(пар_ШтрихКод);
	Если (СтрДлина(пар_ШтрихКод)<>13) или (_Число(пар_ШтрихКод)=0) Тогда
		// Если длина не соотв. или это не число
		Возврат 0;
	КонецЕсли;
    
	КонтрольнаяСумма=Число(Сред(пар_ШтрихКод,13,1));
	Для а=1 по 12 Цикл
		Если а%2>0  Тогда
			Нечетные=Нечетные+Число(Сред(пар_ШтрихКод,а,1));
		Иначе
			Четные=Четные+Число(Сред(пар_ШтрихКод,а,1));
		КонецЕсли;                                    
	КонецЦикла;                                        
	Общее=Нечетные+(Четные*3);

	Результат=10-(Общее-Цел(Общее/10)*10);
    
	Возврат ?(КонтрольнаяСумма=?(Результат=10,0,Результат),1,0);
КонецФункции

Функция Стр_ЭтоЧисло(Знач пар_1) Экспорт
	пер_1=СтрЗаменить(пар_1," ","");
	
	Если пер_1<>"" Тогда
		Попытка
			пер_1=Число(пер_1);
			Возврат Истина;
		Исключение
		КонецПопытки;
	КонецЕсли;
	
	Возврат Ложь;
КонецФункции

Функция Стр_ВСписокЗначений(пар_СЗ, Знач пар_СЗилиСтрока, Знач пар_Разделитель=",") Экспорт
	пар_СЗ.Очистить();
	
	Если Строка(ТипЗнч(пар_СЗилиСтрока))="Список значений" Тогда
		// СПИСОК ЗНАЧЕНИЙ
		пар_СЗ.ЗагрузитьЗначения(пар_СЗилиСтрока.ВыгрузитьЗначения());
	Иначе
		// СТРОКА
		пер_Поля = СокрЛП(пар_СЗилиСтрока);
		
		Пока пер_Поля<>"" Цикл
			// Находим разделитель
			пер_К 		= Найти(пер_Поля, пар_Разделитель);
			// Определяем имя поля
			пер_Поле	= ?(пер_К>0, Лев(пер_Поля, пер_К), пер_Поля);
			// Исключаем поле из списка
			пер_Поля	= Прав(пер_Поля, СтрДлина(пер_Поля)-СтрДлина(пер_Поле));
			// Приводим имя поля к нормальному виду
			пер_Поле	= СокрЛП(СтрЗаменить(пер_Поле, пар_Разделитель, ""));
			Если пер_Поле<>"" Тогда
				пар_СЗ.Добавить(пер_Поле);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;

	Возврат пар_СЗ.Количество();
КонецФункции

Функция Стр_2Тип1С(пар_1) Экспорт
	// Избавляемся от скобок и пробелов
	пер_1 = ВРег(СтрЗаменить(СтрЗаменить(СтрЗаменить(СокрЛП(пар_1)," ",""),"(",""),")",""));
	
	Если (Лев(пер_1,1)="S") или (Лев(пер_1,1)="C") Тогда
		// Строка
		ОписТип=Новый ОписаниеТипов("Строка", Новый КвалификаторыСтроки(_Число(Сред(пер_1,2))));
	ИначеЕсли Лев(пер_1,1)="D" Тогда
		// Дата
		ОписТип=Новый ОписаниеТипов("Дата", 	Новый КвалификаторыДаты());
	ИначеЕсли Лев(пер_1,1)="N" Тогда
		// Число
		пер_ДЧ =0;
		пер_ПозЗпт=Найти(пер_1,",");
		
		Если (пер_ПозЗпт>2) Тогда
			пер_ДЧ= _Число(Сред(пер_1, пер_ПозЗпт+1));
			пер_1	= Лев(пер_1, пер_ПозЗпт-1);
		КонецЕсли;
		
		ОписТип=Новый ОписаниеТипов("Число", 	Новый КвалификаторыЧисла(_Число(Сред(пер_1,2)), пер_ДЧ, ДопустимыйЗнак.Любой));
	КонецЕсли;
	
	Возврат ОписТип;
КонецФункции

Функция Стр_ТипDBF(Знач пар_1) Экспорт
	// Определяем по первым символам
	пер_тип=НРег(Лев(СокрЛП(пар_1),1));
	Если 			(пер_тип="s") или (пер_тип="c") или (пер_тип="с") Тогда
		Возврат "S";
	ИначеЕсли (пер_тип="n") 									или (пер_тип="ч") Тогда
		Возврат "N";
	ИначеЕсли (пер_тип="d") 									или (пер_тип="д") Тогда
		Возврат "D";
	ИначеЕсли (пер_тип="l") 									или (пер_тип="л") или (пер_тип="б") Тогда
		Возврат "L";
	КонецЕсли;
	Возврат "";
КонецФункции

//**********************************************************************
Функция СЗ_ВСтрокуСРазделителем(пар_СЗилиСтрока, Знач пар_Разделитель=",") Экспорт
	пер_Возврат="";
	Если Строка(ТипЗнч(пар_СЗилиСтрока))="Список значений" Тогда
		// СПИСОК ЗНАЧЕНИЙ
		Для Каждого стр Из пар_СЗилиСтрока Цикл
			пер_Возврат=пер_Возврат+?(пер_Возврат="","",",")+Строка(стр.Значение);
		КонецЦикла;
	Иначе
		// СТРОКА
		пер_Возврат=пар_СЗилиСтрока;
	КонецЕсли;
	
	Возврат пер_Возврат;
КонецФункции

Функция СЗ_СПометкамиВНовыйСписок(пар_СписокИсточник, пар_СписокПриемник, пар_ПредварительноОчистить=1) Экспорт
	пер_Счетчик=0;
	Если пар_ПредварительноОчистить=1 Тогда
		пар_СписокПриемник.Очистить();
	КонецЕсли;
	
	Для каждого стр из пар_СписокИсточник Цикл
		Если стр.Пометка Тогда
			пар_СписокПриемник.Добавить(стр.Значение);
			пер_Счетчик=пер_Счетчик+1;
		КонецЕсли;
	КонецЦикла;
	Возврат пер_Счетчик;
КонецФункции

//**********************************************************************
Функция DBF_НаличиеПолей(о_XBase, пар_СписокПолейИсх, Знач пар_ПоказыватьОшибки=1) Экспорт
	// Объект о_XBase должен быть открыт

	// Создаем временный список значений и приводим значения в верхний регистр
	пер_СписокПолей = Новый СписокЗначений;
	
	Если Стр_ВСписокЗначений(пер_СписокПолей, пар_СписокПолейИсх)=0 Тогда
		Если пар_ПоказыватьОшибки=1 Тогда
			Сообщить("ОШИБКА! Список полей для проверки пуст");
		КонецЕсли;
	ИначеЕсли НЕ о_XBase.Открыта() Тогда
		// Объект о_XBase не открыт
		Если пар_ПоказыватьОшибки=1 Тогда
			Сообщить("ОШИБКА! Проверка наличия полей невозможна, т.к. DBF файл не открыт");
		КонецЕсли;
	Иначе
		Для Ц=0 По о_XBase.поля.Количество()-1 Цикл
			пер_НачатьС = 0;
~Повтор1:			
			Для Ф=пер_НачатьС По пер_СписокПолей.Количество()-1 Цикл
				Если ВРег(СокрЛП(о_XBase.поля[Ц].Имя))=ВРег(СокрЛП(пер_СписокПолей[ф].Значение)) Тогда
					пер_СписокПолей.Удалить(Ф);
					пер_НачатьС=ф;
					Перейти ~Повтор1; // Повтор нужен на тот случай, если в списке будет повтор полей
				КонецЕсли;
			КонецЦикла;
		КонецЦикла;
		
		Если пер_СписокПолей.Количество()=0 Тогда
			Возврат Истина;
		ИначеЕсли пар_ПоказыватьОшибки=1 Тогда
			Сообщить("ОШИБКА! Поля не существуют: "+СЗ_ВСтрокуСРазделителем(пер_СписокПолей));
		КонецЕсли;
	КонецЕсли;
	
	Возврат Ложь;
КонецФункции

Функция DBF_ПолучитьСписокПолей(о_XBase, Знач пар_ПоказыватьОшибки=1) Экспорт
	сз_СписокПолей = Новый СписокЗначений;
	
	// Объект о_XBase должен быть открыт
	Если НЕ о_XBase.Открыта() Тогда
		// Объект о_XBase не открыт
		Если пар_ПоказыватьОшибки=1 Тогда
			Сообщить("ОШИБКА! Получение списка полей невозможно, т.к. DBF файл не открыт");
		КонецЕсли;
	Иначе
		Для Ц=0 По о_XBase.поля.Количество()-1 Цикл
			сз_СписокПолей.Добавить(о_XBase.поля[Ц].Имя);
		КонецЦикла;
	КонецЕсли;
	
	Возврат сз_СписокПолей;
КонецФункции

Функция DBF_ADODB_Запрос(Знач пар_Каталог="", Знач пар_ТекстSQL, Знач пар_ОбрУдаленные=0, Знач пар_ВернутьТЗ=0, Знач пар_СтрокаСоединения="", Знач пар_ТипыКолонок="") Экспорт
	// Разделитель для типа колонок = ;
	
	пер_Возврат	= Ложь;
	Таблица = Новый ТаблицаЗначений;
	
	Если пар_ТипыКолонок<>"" Тогда
		// Если тип колонок передали, то преобразуем строку в список значений
		сп_ТипКол = Новый СписокЗначений;
		Стр_ВСписокЗначений(сп_ТипКол, пар_ТипыКолонок, ";");
	КонецЕсли;

	Попытка
		Соединение=Новый COMОбъект("ADODB.Connection"); 
		Если пар_СтрокаСоединения="" Тогда
			Соединение.Open("provider=vfpoledb.1;data source="+пар_Каталог); 
		Иначе
			//"Provider=SQLOLEDB.1;Data Source=z170;Initial Catalog=a5v2;User Id=sa;Password=;"
			Соединение.Open(пар_СтрокаСоединения); 
		КонецЕсли;
	
		Попытка
			Cmd = Новый COMОбъект("ADODB.Command"); 
			Cmd.ActiveConnection = Соединение; 
			Cmd.CommandText = пар_ТекстSQL;
			ЗаписиSQL = Новый ComObject("ADODB.RecordSet");
			
			Попытка
				#Если   Клиент Тогда
					
					Состояние ("Выполнение запроса SQL...");
				#Конецесли 
				Если пар_ВернутьТЗ=0 Тогда
					Cmd.Execute();
				Иначе
					ЗаписиSQL=Cmd.Execute();
					//--------------------
					#Если   Клиент Тогда
						Состояние ("Заполнение временной таблицы...");
					#Конецесли 
					
					Для НомерСтолбца = 0 По ЗаписиSQL.Fields.Count-1 Цикл //Создание и добавление колонок во временную таблицу
						ИмяСтолбца =ЗаписиSQL.Fields.Item(НомерСтолбца).Name; 
						Если пар_ТипыКолонок="" Тогда
							// Если типы колонок не передавались - Добавляем колонку без типизации
							Таблица.Колонки.Добавить(ИмяСтолбца);
						Иначе
							Если (сп_ТипКол[НомерСтолбца].Значение="") Тогда
								// Если типы колонок передавались, но для текущей колонки нет определения - Добавляем колонку без типизации
								Таблица.Колонки.Добавить(ИмяСтолбца);
							Иначе
								// Добавляем колонку с типизацией
								Таблица.Колонки.Добавить(ИмяСтолбца, Стр_2Тип1С(сп_ТипКол[НомерСтолбца].Значение) );
							КонецЕсли;
						КонецЕсли;
					КонецЦикла;

					Пока ЗаписиSQL.EOF = 0 Цикл // Заполнение созданной таблицы
					  //Состояние(Строка(Цел((Ц-пар_НачСтрока+1)/(пар_КолСтрок/100)))+"%");
						НоваяСтрока =  Таблица.Добавить();
						Для НомерСтолбца = 0 По ЗаписиSQL.Fields.Count-1 Цикл
					 		НоваяСтрока.Установить(НомерСтолбца,ЗаписиSQL.Fields(НомерСтолбца).Value);
						КонецЦикла;
						ЗаписиSQL.MoveNext();
					КонецЦикла;
				КонецЕсли;
				//--------------------
				пер_Возврат=Истина;
			Исключение
				Попытка
					ЗаписиSQL.Close();
				Исключение
				КонецПопытки;
			КонецПопытки;
		Исключение
			#Если   Клиент Тогда
			Сообщить(Cmd.CommandText);
			Сообщить(ОписаниеОшибки());
			#Конецесли 
		КонецПопытки;
		
		Соединение.Close();
	Исключение
		#Если   Клиент Тогда
			
			Сообщить("ОШИБКА! Невозможно установить соединение с ADODB.Connection: "+ОписаниеОшибки());
		#Конецесли 
	КонецПопытки;
	
	Если пер_Возврат Тогда
		Возврат ?(пар_ВернутьТЗ=0, Истина, Таблица);
	КонецЕсли;
	
	Возврат ?(пар_ВернутьТЗ=0, Ложь, Неопределено);
КонецФункции

Функция DBF_ОткрытьФайлМонопольно(о_XBase, Знач пар_ПутьКБазе="", Знач пар_ПутьКИндексу="") Экспорт
	Попытка
		о_XBase.ОткрытьФайл(пар_ПутьКБазе, пар_ПутьКИндексу);
	Исключение
	КонецПопытки;
	
	Если о_XBase.Открыта() Тогда
		Возврат Истина;
	Иначе
		Попытка
			о_XBase.ОткрытьФайл(пар_ПутьКБазе, пар_ПутьКИндексу, 1);
		Исключение
		КонецПопытки;
		
		Если о_XBase.Открыта() Тогда
			о_XBase.ЗакрытьФайл();
			// Файл используется другой задачей
			Сообщить("ОШИБКА! Файл используется другой задачей");
		Иначе 
			// Не удалось открыть файл
			Сообщить("ОШИБКА! Не удалось открыть файл");
		КонецЕсли;
	КонецЕсли;
	
	Возврат Ложь;
КонецФункции

Функция DBF_Тип2Тип1С(пар_Поле) Экспорт
	Если 			пар_Поле.Тип="S" Тогда
		ОписТип=Новый ОписаниеТипов("Строка", Новый КвалификаторыСтроки(пар_Поле.Длина));
	ИначеЕсли пар_Поле.Тип="N" Тогда
		ОписТип=Новый ОписаниеТипов("Число", 	Новый КвалификаторыЧисла(пар_Поле.Длина, пар_Поле.Точность, ДопустимыйЗнак.Любой));
	ИначеЕсли пар_Поле.Тип="D" Тогда
		ОписТип=Новый ОписаниеТипов("Дата", 	Новый КвалификаторыДаты());
	ИначеЕсли пар_Поле.Тип="L" Тогда
		ОписТип=Новый ОписаниеТипов("Число", 	Новый КвалификаторыЧисла(1, 0, ДопустимыйЗнак.Неотрицательный));
	КонецЕсли;
	
	Возврат ОписТип;
КонецФункции

Функция DBF_СкопироватьСтруктуруВТЗ(о_XBase, ТЗ, Знач пар_СписокПолей="", Знач пар_ПоказыватьОшибки=1) Экспорт
	ТЗ.Колонки.Очистить();
	
	пер_СписокПолей = Новый СписокЗначений;
	Стр_ВСписокЗначений(пер_СписокПолей, пар_СписокПолей);
	
	Если пер_СписокПолей.Количество()=0 Тогда
		// Добавляем все колонки в ТЗ
		Для Ц=0 По о_XBase.поля.Количество()-1 Цикл
			ТЗ.Колонки.Добавить(о_XBase.поля[Ц].Имя, DBF_Тип2Тип1С(о_XBase.поля[Ц]));
		КонецЦикла;
	Иначе
		пер_Возврат=Истина;
		Для Каждого стр Из пер_СписокПолей Цикл
			// Проверка наличия поля
			Попытка
				Если ТЗ.Колонки.Найти(ВРег(стр.Значение)) = Неопределено Тогда
					ТЗ.Колонки.Добавить(ВРег(стр.Значение), DBF_Тип2Тип1С(о_XBase.поля.Найти(стр.Значение)));
				КонецЕсли;
			Исключение
				Если пар_ПоказыватьОшибки=1 Тогда
					Сообщить("ОШИБКА! Невозможно добавить поле : "+стр.Значение + " описание : " + ОписаниеОшибки());
				КонецЕсли;
				пер_Возврат=Ложь;           
			КонецПопытки;
		КонецЦикла;
		
		Возврат пер_Возврат;
	КонецЕсли;
	
	Возврат Истина;
КонецФункции

Функция DBF_СкопироватьДанныеВТЗ(о_XBase, ТЗ, Знач пар_СписокПолей="", Знач пар_НачСтрока=1, Знач пар_КолСтрок=0, Знач пар_ПоказыватьОшибки=1) Экспорт
	ТЗ.Очистить();
	
	пер_СписокПолей = Новый СписокЗначений;
	Стр_ВСписокЗначений(пер_СписокПолей, пар_СписокПолей);

	пар_НачСтрока	= Макс(пар_НачСтрока,1);
	пар_КолСтрок	= ?(пар_КолСтрок<=0, о_XBase.КоличествоЗаписей(), Мин(о_XBase.КоличествоЗаписей(), пар_КолСтрок));
	
	Если пер_СписокПолей.Количество()=0 Тогда
		пер_СписокПолей=DBF_ПолучитьСписокПолей(о_XBase);
	КонецЕсли;
	
	// Для скорости
	сп_СписокСоотвИндексов = Новый СписокЗначений;
	Для Ц=0 По пер_СписокПолей.Количество()-1 Цикл
		сп_СписокСоотвИндексов.Добавить(ТЗ.Колонки.Индекс(ТЗ.Колонки.Найти(пер_СписокПолей.Получить(Ц).Значение)));
	КонецЦикла;
	
	// Побежали по строчкам
	Для Ц=пар_НачСтрока По (пар_НачСтрока+пар_КолСтрок-1) Цикл
		
		#Если   Клиент Тогда
			
			Состояние(Строка(Цел((Ц-пар_НачСтрока+1)/(пар_КолСтрок/100)))+"%");
		#Конецесли 
			
		// Спозиционировались в DBF и добавили новую строку в ТЗ
		о_XBase.Перейти(Ц);
		НоваяСтрока = ТЗ.Добавить();
		
		// По каждой колонке
		Для К=0 По пер_СписокПолей.Количество()-1 Цикл
			НоваяСтрока.Установить(сп_СписокСоотвИндексов.Получить(К).Значение, о_XBase.ПолучитьЗначениеПоля(пер_СписокПолей.Получить(К).Значение));
		КонецЦикла;
	КонецЦикла;
		
	Возврат Истина;
КонецФункции

Функция DBF_СкопироватьСтруктуруИДанныеВТЗ(о_XBase, ТЗ, Знач пар_СписокПолей="", Знач пар_НачСтрока=1, Знач пар_КолСтрок=0, Знач пар_ПоказыватьОшибки=1) Экспорт
	// Копируем структуру
	Если DBF_СкопироватьСтруктуруВТЗ(о_XBase, ТЗ, пар_СписокПолей) Тогда
		// Копируем данные
		Если DBF_СкопироватьДанныеВТЗ(о_XBase, ТЗ, пар_СписокПолей, пар_НачСтрока, пар_КолСтрок, пар_ПоказыватьОшибки) Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЕсли;
	Возврат Ложь;
КонецФункции

Функция DBF_СоздатьИзСпрСтруктураФайлов(o_XBase, Знач пар_Поставщик, Знач пар_Файл, пар_ТЗСоотв) Экспорт
	пар_ТЗСоотв.Колонки.Очистить();
	пар_ТЗСоотв.Колонки.Добавить("ИмяПоля");
	пар_ТЗСоотв.Колонки.Добавить("Тип");
	пар_ТЗСоотв.Колонки.Добавить("ИмяПоляБД");
	
	// Получаем структуру DBF
	Запрос = Новый Запрос;
	Запрос.Текст = "
	|SELECT
	|  ИмяПоля, Тип, Длина, Точность, ИмяПоляБД
	|FROM
	|  Справочник.СтруктураФайлов.Заказ КАК Т1
	|WHERE
	|  (Ссылка.Владелец=&Владелец) and (ИмяПоля<>"""") and (Тип<>"""")
	|";
	
	Запрос.УстановитьПараметр("Владелец", пар_Поставщик);
	ТЗ_Структура = Новый ТаблицаЗначений;
	ТЗ_Структура = Запрос.Выполнить().Выгрузить();
	
	// Удалить существующий файл
	Если НЕ ОМ20_Чернов.ФС_УдалитьФайл(пар_Файл) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Попытка
		Для Каждого стр Из ТЗ_Структура Цикл
			пер_тип=Стр_ТипDBF(стр.Тип);
			o_XBase.поля.Добавить(стр.ИмяПоля, пер_тип, стр.Длина, стр.Точность);
			// И попутно заполняем ТЗ для последующего возврата
			НоваяСтрока = пар_ТЗСоотв.Добавить();
			НоваяСтрока.ИмяПоля 	= стр.ИмяПоля;
			НоваяСтрока.Тип				= пер_тип;
			НоваяСтрока.ИмяПоляБД	= стр.ИмяПоляБД;
		КонецЦикла;
		
		// Определяем кодировку
		стр = Справочники.СтруктураФайлов.Выбрать(,пар_Поставщик);
		Если стр.Следующий() Тогда
			o_XBase.Кодировка = ?(стр.Кодировка="OEM", КодировкаXBase.OEM, КодировкаXBase.ANSI);
		Иначе
			o_XBase.Кодировка = КодировкаXBase.OEM;
		КонецЕсли;
		
		o_XBase.СоздатьФайл(пар_Файл);
		// Файлик ГОТОВ - выходим
		Возврат Истина;
	Исключение
		Сообщить(ОписаниеОшибки());
		пар_ТЗСоотв.Очистить();
	КонецПопытки;
	
	Если o_XBase.Открыта() Тогда
		o_XBase.ЗакрытьФайл();
		ОМ20_Чернов.ФС_УдалитьФайл(пар_Файл);
	КонецЕсли;
	Возврат Ложь;
КонецФункции

//**********************************************************************
Функция ТЗ_ВоВременнуюТаблицу(пар_Запрос, пар_ТЗ, пар_ИмяВременнойТаблицы) Экспорт
	пар_Запрос.МенеджерВременныхТаблиц=Новый МенеджерВременныхТаблиц;
	пар_Запрос.Текст = "Выбрать * Поместить "+пар_ИмяВременнойТаблицы+" из &Таблица  Как ВнешнийИсточник";
	пар_Запрос.УстановитьПараметр("Таблица", пар_ТЗ);
	Попытка
		пар_Запрос.Выполнить();
	Исключение
		Возврат Ложь;
	КонецПопытки;
	
	Возврат Истина;
КонецФункции

Функция ТЗ_СуществуетКолонка(пар_ТЗ, Знач пар_Кол, Знач пар_ПоказыватьОшибки=1) Экспорт
	Если пар_ТЗ.Колонки.Найти(пар_Кол)=Неопределено Тогда
		Если пар_ПоказыватьОшибки=1 Тогда
			Сообщить("ОШИБКА! Поле DBF не найдено: "+пар_Кол);
		КонецЕсли;
		Возврат Ложь;
	КонецЕсли;
	
	Возврат Истина;
КонецФункции

Функция ТЗ_СуществуетСписокКолонок(пар_ТЗ, пар_СписокКолонок, Знач пар_ПоказыватьОшибки=1) Экспорт
	// Создаем временный список значений и приводим значения в верхний регистр
	сз_СписокПолей 								 = Новый СписокЗначений;
	сз_СписокНесуществующихКолонок = Новый СписокЗначений;
	
	Если Стр_ВСписокЗначений(сз_СписокПолей, пар_СписокКолонок)=0 Тогда
		Если пар_ПоказыватьОшибки=1 Тогда
			Сообщить("ОШИБКА! Список полей для проверки пуст");
		КонецЕсли;
	Иначе
		Для Каждого стр Из сз_СписокПолей Цикл
			Если НЕ ТЗ_СуществуетКолонка(пар_ТЗ, стр.Значение, 0) Тогда
				сз_СписокНесуществующихКолонок.Добавить(стр.Значение);
			КонецЕсли;
		КонецЦикла;
		
		Если сз_СписокНесуществующихКолонок.Количество()=0 Тогда
			Возврат Истина;
		ИначеЕсли пар_ПоказыватьОшибки=1 Тогда
			Сообщить("ОШИБКА! Колонки не существуют: "+СЗ_ВСтрокуСРазделителем(сз_СписокНесуществующихКолонок));
		КонецЕсли;
	КонецЕсли;

	Возврат Ложь;
КонецФункции

Функция ТЗ_ОпределитьФорматДатыВКолонке(ТЗ, Знач пар_Кол, Знач пар_КолонкаОдногоТипа=Ложь) Экспорт
	ТЗ2 = Новый ТаблицаЗначений;
	ТЗ2.Колонки.Добавить("ФорматДаты");
	ТЗ2.Колонки.Добавить("Количество");
	
	МК = ТЗ.ВыгрузитьКолонку(пар_Кол);
	Для Каждого стр Из МК Цикл
		пер_Формат = Стр_ПолучитьФорматДаты(стр);
		Если пер_Формат<>"" Тогда
			пер_ссылка = ТЗ2.Найти(пер_Формат, "ФорматДаты");
			Если пер_ссылка=Неопределено Тогда
				Если пар_КолонкаОдногоТипа и (пер_Формат="Дата") Тогда
					// Если колонка одного типа - "Дата" то дальше ничего не ищем
					Возврат пер_Формат;
				КонецЕсли;
				
				// Добавляем новый формат даты
				пер_ссылка = ТЗ2.Добавить();
				пер_ссылка.ФорматДаты = пер_Формат;
				пер_ссылка.Количество = 1;
			Иначе
				// Увеличиваем счетчик у определенного формата даты
				пер_ссылка.Количество = пер_ссылка.Количество+1;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Если ТЗ2.Количество()>0 Тогда
		// Если был определен хотя бы один формат
		ТЗ2.Сортировать("Количество Убыв");
		Возврат ТЗ2[0].ФорматДаты;
	КонецЕсли;
	
	Возврат "";
КонецФункции

//**********************************************************************
Функция ФС_УдалитьФайл(Знач пар_Файл, Знач пар_ПоказыватьОшибки=1) Экспорт
	о_Файл = Новый Файл(пар_Файл);
	
	Если НЕ о_Файл.Существует() Тогда
		Возврат Истина;
	Иначе
		Попытка
			УдалитьФайлы(пар_Файл);
		Исключение
		КонецПопытки;
		
		Если пар_ПоказыватьОшибки=1 Тогда
			Если о_Файл.Существует() Тогда
				Сообщить("ОШИБКА! Невозможно удалить файл: "+пар_Файл);
				Возврат Ложь;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	Возврат НЕ о_Файл.Существует();
КонецФункции

Функция ФС_КопироватьФайл(Знач пар_ФайлИсточник, Знач пар_ФайлПриемник, Знач пар_Перезаписать=1, Знач пар_ПоказыватьОшибки=1) Экспорт
	пер_Ошибка= "";
	
	// Проверка источника
	о_Файл = Новый Файл(пар_ФайлИсточник);
	Если НЕ (о_Файл.Существует()) Тогда
		пер_Ошибка= "Файл источник не существует: "+пар_ФайлИсточник;
	Иначе
		// Проверка приемника
		о_Файл = Новый Файл(пар_ФайлПриемник);
		Если о_Файл.Существует() Тогда
			Если пар_Перезаписать=1 Тогда
				// Удалить приемник
				Если НЕ ФС_УдалитьФайл(пар_ФайлПриемник,0) Тогда
					пер_Ошибка= "Не удалось удалить старый файл: "+пар_ФайлПриемник;
				КонецЕсли;
			Иначе
				// Перезапись запрещена
				пер_Ошибка= "Файл уже существует: "+пар_ФайлПриемник;
			КонецЕсли;
		КонецЕсли;
		
		// Копировать
		Если пер_Ошибка="" Тогда
			КопироватьФайл(пар_ФайлИсточник, пар_ФайлПриемник);
			// Проверить успешность копирования
			Если о_Файл.Существует() Тогда
				Возврат Истина;
			Иначе
				пер_Ошибка = пар_ФайлИсточник;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	Если пар_ПоказыватьОшибки=1 Тогда
		Сообщить("Ошибка копирования: "+пер_Ошибка);
	КонецЕсли;
	
	Возврат Ложь;
КонецФункции

Функция ФС_ВыбратьФайл(Знач пар_РасширениеФайла="") Экспорт
	// Выбор файла с указанным расширением
	#Если   Клиент ТОгда
		ДОФ = Новый ДиалогВыбораФайла(РежимДиалогаВыбораФайла.Открытие);
		ДОФ.ПолноеИмяФайла = "";
		ДОФ.Фильтр = ВРег(пар_РасширениеФайла)+"|*."+НРег(пар_РасширениеФайла);
		ДОФ.Заголовок = "Выберите "+ВРег(пар_РасширениеФайла)+" файл";
		Если ДОФ.Выбрать() Тогда
			Возврат ДОФ.ПолноеИмяФайла;
		КонецЕсли;
	#Конецесли 
	Возврат "";
КонецФункции

Функция ФС_ВыбратьФайлВ(Знач пар_РасширениеФайла="", пар_Получатель) Экспорт
	пер_Файл = ФС_ВыбратьФайл(пар_РасширениеФайла);
	Если НЕ ПустаяСтрока(пер_Файл) Тогда
		пар_Получатель=пер_Файл;
		Возврат Истина;
	КонецЕсли;
	Возврат Ложь;
КонецФункции

Функция ФС_СоздатьКаталог(Знач пар_Каталог) Экспорт
	// Убираем лишние пробелы
	пер_Каталог=СокрЛП(пар_Каталог);
	
	// Убираем конечный \ если он есть
	Если Прав(пер_Каталог,1)="\" Тогда
		пер_Каталог=Лев(пер_Каталог, СтрДлина(пер_Каталог)-1);
	КонецЕсли;
	
	о_Файл = Новый Файл(пер_Каталог);
	
	Если НЕ о_Файл.Существует() Тогда
		Если ((Лев(пар_Каталог,2)<>"\\") и (Сред(пар_Каталог,2,2)<>":\")) Тогда
			Возврат Ложь;
		Иначе
			// Каталог не существует, создаем
			СоздатьКаталог(пер_Каталог);
			
			Если НЕ о_Файл.Существует() Тогда
				Сообщить("ОШИБКА! Не удалось создать каталог:  "+Символы.ВК+"  "+пар_Каталог);
				Возврат Ложь;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	// Если есть, проверяем каталог-ли это
	Если НЕ о_Файл.ЭтоКаталог() Тогда
		// Сущ. одноименный файл!
		Сообщить("ОШИБКА! Невозможно создать каталог, т.к. сущ. файл с аналогичным именем: "+Символы.ВК+"  "+пар_Каталог);
		Возврат Ложь;
	КонецЕсли;
	
	// Каталог существует
	Возврат Истина;
КонецФункции // ФС_КаталогСуществует

Функция ФС_ФайлСуществует(Знач пар_Файл, Знач пар_ПоказыватьОшибки=0) Экспорт
	о_Файл = Новый Файл(пар_Файл);
	Если НЕ (о_Файл.Существует()) Тогда
	ИначеЕсли о_Файл.ЭтоФайл() Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если пар_ПоказыватьОшибки=1 Тогда
		Сообщить("Файл не существует: "+пар_Файл);
	КонецЕсли;
	
	Возврат Ложь;
КонецФункции

Функция ФС_КаталогСуществует(Знач пар_Файл, Знач пар_ПоказыватьОшибки=0) Экспорт
	о_Файл = Новый Файл(пар_Файл);
	Если НЕ (о_Файл.Существует()) Тогда
	ИначеЕсли о_Файл.ЭтоКаталог() Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если пар_ПоказыватьОшибки=1 Тогда
		Сообщить("Каталог не существует: "+пар_Файл);
	КонецЕсли;
	
	Возврат Ложь;
КонецФункции

Функция ФС_ФайлИлиКаталогСуществует(Знач пар_Файл) Экспорт
	о_Файл = Новый Файл(пар_Файл);
	Если о_Файл.Существует() Тогда
		Возврат Истина;
	КонецЕсли;
	
	Возврат Ложь;
КонецФункции

Функция ФС_ДопустимыеСимволыФайла(пар_Файл, Знач пар_ENG = Истина, Знач пар_RUS = Истина, Знач пар_NUM = Истина, Знач пар_OTH = "- _.") Экспорт
	пер_Файл = НРег(СокрЛП(пар_Файл));
	пер_ENG = "qwertyuiopasdfghjklzxcvbnm";
	пер_RUS = "йцукенгшщзхъфывапролджэячсмитьбюё";
	пер_NUM = "1234567890";
	
	пер_ALL = ?(пар_ENG,пер_ENG,"")+?(пар_RUS,пер_RUS,"")+?(пар_NUM,пер_NUM,"")+пар_OTH;
	
	пер_ЗапрещенныеСимв = "";
	Для Ц=1 По СтрДлина(пер_Файл) Цикл
		Если Найти(пер_ALL, Сред(пер_Файл,Ц,1))=0 Тогда
			Сообщить("Разрешено использовать только следующие символы: "+пер_ALL);
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Истина;
КонецФункции

Функция ФС_КаталогВременныхФайлов() Экспорт
		Для Ц=0 По 999 Цикл
			пер_Каталог = КаталогВременныхФайлов()+Формат(ТекущаяДата(),"ДФ=""гггг-ММ-дд ЧЧ-мм-сс""")+Прав(" 00000"+_Строка(Ц),7) ;
			Если НЕ ФС_КаталогСуществует(пер_Каталог) Тогда
				Если ФС_СоздатьКаталог(пер_Каталог) Тогда
					Возврат пер_Каталог+"\";
				Иначе
					Возврат "";
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
	
	Возврат "";
КонецФункции

//**********************************************************************
Функция Спр_Код2ЭлСпр(Знач пар_Справочник, Знач пар_Код, Знач пар_Родитель=Неопределено, Знач пар_Владелец=Неопределено, Знач пар_ПоказыватьОшибки=1) Экспорт
	Спр = Справочники[пар_Справочник];
	Рез = Спр.НайтиПоКоду(пар_Код,,пар_Родитель,пар_Владелец);
	
	Если Рез.Пустая() и (пар_ПоказыватьОшибки=1) Тогда
		Сообщить("Не удалось найти код: "+Строка(пар_Код)+" в справочнике "+пар_Справочник);
	КонецЕсли;
	
	Возврат Рез;	
КонецФункции

Функция Спр_Наименование2ЭлСпр(Знач пар_Справочник, Знач пар_Наименование, Знач пар_Родитель=Неопределено, Знач пар_Владелец=Неопределено, Знач пар_ПоказыватьОшибки=1) Экспорт
	Спр = Справочники[пар_Справочник];
	Рез = Спр.НайтиПоНаименованию(пар_Наименование,,пар_Родитель,пар_Владелец);
	
	Если Рез.Пустая() и (пар_ПоказыватьОшибки=1) Тогда
		Сообщить("Не удалось найти наименование: "+пар_Наименование+" в справочнике "+пар_Справочник);
	КонецЕсли;
	
	Возврат Рез;	
КонецФункции

Функция Спр_Реквизит2ЭлСпр(Знач пар_Справочник, Знач пар_ИмяРеквизита, Знач пар_ЗначениеРеквизита, Знач пар_Родитель=Неопределено, Знач пар_Владелец=Неопределено, Знач пар_ПоказыватьОшибки=1) Экспорт
	Спр = Справочники[пар_Справочник];
	Рез = Спр.НайтиПоРеквизиту(пар_ИмяРеквизита, пар_ЗначениеРеквизита, пар_Родитель, пар_Владелец);
	
	Если Рез.Пустая() и (пар_ПоказыватьОшибки=1) Тогда
		Сообщить("Не удалось найти по реквизиту: "+пар_ИмяРеквизита+" значение: "+Строка(пар_ЗначениеРеквизита)+" в справочнике "+пар_Справочник);
	КонецЕсли;
	
	Возврат Рез;	
КонецФункции

Функция Спр_ПолучитьСправочникВладельцаСтр(Знач пар_спр, пар_Возврат) Экспорт
	// Возвращаемые значения:
	// У справочника нет владельцев														- ИСТИНА (пар_Возврат содержит пустую строку)
	// У справочника один владелец с типом СПРАВОЧНИК					- ИСТИНА (пар_Возврат содержит имя справочника владельца)
	
	// У справочника один владелец тип которого НЕ СПРАВОЧНИК - ЛОЖЬ (пар_Возврат содержит пустую строку)
	// У справочника более одного владельца										- ЛОЖЬ (пар_Возврат содержит пустую строку)
	
	пар_Возврат = "";
	пер_спр			= Строка(пар_спр);
	
	Если ((пер_спр="Булево") или (пер_спр="Число") или (пер_спр="Строка") или (пер_спр="Дата")) Тогда
		Возврат Истина;
	КонецЕсли;
	
	пер_КолВладельцев = Метаданные.Справочники[пер_спр].Владельцы.Количество();
	
	Если пер_КолВладельцев>1 Тогда
		Сообщить("ОШИБКА! Справочник может иметь разные типы владельцев: "+пер_спр);
		Возврат Ложь;
	ИначеЕсли пер_КолВладельцев=1 Тогда
		// Один владелец
		Для Каждого рек Из Метаданные.Справочники[пер_спр].Владельцы Цикл
			пер_ИндексСправочника=Метаданные.Справочники.Индекс(рек);
			Если пер_ИндексСправочника>=0 Тогда
				// Один владелец тип - справочник
				пар_Возврат = Метаданные.Справочники[пер_ИндексСправочника].Имя;
			Иначе
				// Один владелец тип - НЕ справочник
				Сообщить("ОШИБКА! Справочник имеет владельца отличным от типа Справочник: "+пер_спр);
				Возврат Ложь;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;

	Возврат Истина;
КонецФункции

Функция Спр_ПолучитьТипРеквизитаСтр(Знач пар_спр, Знач пар_Реквизит, пар_Возврат) Экспорт
	// Возвращаемые значения:
	// Для реквизита простой тип									- ИСТИНА	(пар_Возврат содержит "Булево", "Число", "Строка", "Дата")
	// Для реквизита с одним типом СПРАВОЧНИК			- ИСТИНА	(пар_Возврат содержит имя справочника)
	// Для реквизита с одним типом НЕ СПРАВОЧНИК	- ЛОЖЬ		(пар_Возврат содержит пустую строку)
	// Для реквизита с несколькими типами					- ЛОЖЬ		(пар_Возврат содержит пустую строку)
	
	пер_спр				= Строка(пар_спр);
	пер_Реквизит	= Строка(пар_Реквизит);
	
	пар_Возврат 	= "";
	пер_тип				= Метаданные.Справочники[пер_спр].Реквизиты[пер_Реквизит].тип;
	
	Если (Строка(пер_тип)="Булево") или (Строка(пер_тип)="Число") или (Строка(пер_тип)="Строка") или (Строка(пер_тип)="Дата") Тогда
		// Для типов Булево, Число, Строка, Дата
		пар_Возврат = Строка(пер_тип);
	Иначе
		// Для типов справочник
		Для каждого тип Из пер_тип.типы() Цикл
			Если пар_Возврат <> "" Тогда
				// реквизит может иметь несколько типов
				пар_Возврат = "";
				Сообщить("ОШИБКА! Реквизит <"+пер_Реквизит+"> в справочнике <"+пер_спр+"> может иметь несколько типов!");
				Прервать;
			Иначе
				пер_тмп = Метаданные.НайтиПоТипу(тип);
				// Проверяем справочник ли это
				пер_ИндексСправочника = Метаданные.Справочники.Индекс(пер_тмп);
				Если пер_ИндексСправочника>=0 Тогда
					// справочник
					пар_Возврат = Метаданные.Справочники[пер_ИндексСправочника].Имя;
				Иначе
					// НЕ справочник
					пар_Возврат = "";
					Сообщить("ОШИБКА! Реквизит <"+пер_Реквизит+"> в справочнике <"+пер_спр+"> не является типом справочник!");
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	Возврат пар_Возврат <> "";
КонецФункции

Процедура Спр_ОчиститьСправочник(пар_спр, Знач пар_Родитель=Неопределено, Знач пар_Владелец=Неопределено) Экспорт
	пер_Успех	=0;
	пер_Ошибка=0;
	
	Выборка = Справочники[Строка(пар_спр)].Выбрать(пар_Родитель, пар_Владелец);
	Пока Выборка.Следующий() Цикл
		стр = Выборка.ПолучитьОбъект();
		Попытка
			стр.Удалить();
			пер_Успех=пер_Успех+1;
		Исключение
			пер_Ошибка=пер_Ошибка+1;
			Сообщить(ОписаниеОшибки());
		КонецПопытки;
	КонецЦикла;
	
	Сообщить("Удалено из справочника "+Строка(пар_спр)+": "+Строка(пер_Успех));
	Если пер_Ошибка>0 Тогда
		Сообщить("Не удалось удалить из справочника "+Строка(пар_спр)+": "+Строка(пер_Успех));
	КонецЕсли;
КонецПроцедуры

//**********************************************************************
Процедура ЗагрузитьНаименованияПроизводителей(пар_ТЗ, пар_ИмяКолонки) Экспорт
	// 20.10.2010 17:29
	#Если   Клиент Тогда
		Состояние("Обновление справочника наименований производителей...");
	#Конецесли 
	
	Попытка
		ТЗ = пар_ТЗ.Скопировать(,пар_ИмяКолонки);
		ТЗ.Свернуть(пар_ИмяКолонки);
		
		Для Каждого стр Из ТЗ Цикл
			пл_Наименование = СокрЛП(стр[пар_ИмяКолонки]);
			Если НЕ ПустаяСтрока(пл_Наименование) Тогда
				Попытка
					Если Справочники.НаименованияПроизводителей.НайтиПоНаименованию(пл_Наименование, Истина).Пустая() Тогда
						Эл = Справочники.НаименованияПроизводителей.СоздатьЭлемент();
						Эл.Наименование = пл_Наименование;
						Эл.ДатаСоздания = ТекущаяДата();
						Эл.Записать();
					КонецЕсли;
				Исключение
					#Если   Клиент Тогда
						Сообщить(ОписаниеОшибки());
					#Конецесли 
				КонецПопытки;
			КонецЕсли;
		КонецЦикла;
	Исключение
		#Если   Клиент Тогда
		Сообщить(ОписаниеОшибки());
		#Конецесли 
	КонецПопытки;
	
	#Если   Клиент Тогда

	Состояние("");
	#Конецесли 
КонецПроцедуры